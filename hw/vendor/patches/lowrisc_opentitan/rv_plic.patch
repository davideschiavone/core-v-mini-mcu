diff --git a/hw/ip/rv_plic/data/rv_plic.hjson b/hw/ip/rv_plic/data/rv_plic.hjson
index c4eb999..e2397ec 100644
--- a/hw/ip/rv_plic/data/rv_plic.hjson
+++ b/hw/ip/rv_plic/data/rv_plic.hjson
@@ -28,6 +28,12 @@
       default: "1",
       local: "true",
     },
+    { name: "PrioWidth",
+      desc: "Width of priority signals",
+      type: "int",
+      default: "3",
+      local: "true",
+    },
   ],
   regwidth: "32",
   registers: [
diff --git a/hw/ip/rv_plic/data/rv_plic.sv.tpl b/hw/ip/rv_plic/data/rv_plic.sv.tpl
index 24b7398..8ca471d 100644
--- a/hw/ip/rv_plic/data/rv_plic.sv.tpl
+++ b/hw/ip/rv_plic/data/rv_plic.sv.tpl
@@ -14,6 +14,8 @@
 // Verilog parameter
 //   MAX_PRIO: Maximum value of interrupt priority
 
+`include "prim_assert.sv"
+
 module rv_plic import rv_plic_reg_pkg::*; #(
   // derived parameter
   localparam int SRCW    = $clog2(NumSrc)
diff --git a/hw/ip/rv_plic/rtl/rv_plic.sv b/hw/ip/rv_plic/rtl/rv_plic.sv
index 3761e70..bb26be2 100644
--- a/hw/ip/rv_plic/rtl/rv_plic.sv
+++ b/hw/ip/rv_plic/rtl/rv_plic.sv
@@ -14,6 +14,8 @@
 // Verilog parameter
 //   MAX_PRIO: Maximum value of interrupt priority
 
+`include "prim_assert.sv"
+
 module rv_plic import rv_plic_reg_pkg::*; #(
   // derived parameter
   localparam int SRCW    = $clog2(NumSrc)
@@ -216,6 +218,7 @@ module rv_plic import rv_plic_reg_pkg::*; #(
     .reg2hw,
     .hw2reg,
 
+    .intg_err_o (),
     .devmode_i  (1'b1)
   );
 
diff --git a/hw/ip/rv_plic/rtl/rv_plic_reg_top.sv b/hw/ip/rv_plic/rtl/rv_plic_reg_top.sv
index ea99b23..2363e98 100644
--- a/hw/ip/rv_plic/rtl/rv_plic_reg_top.sv
+++ b/hw/ip/rv_plic/rtl/rv_plic_reg_top.sv
@@ -4,12 +4,14 @@
 //
 // Register Top module auto-generated by `reggen`
 
+
 `include "prim_assert.sv"
 
-module rv_plic_reg_top (
+module rv_plic_reg_top #(
+    parameter int AW = 9
+) (
   input clk_i,
   input rst_ni,
-
   input  tlul_pkg::tl_h2d_t tl_i,
   output tlul_pkg::tl_d2h_t tl_o,
   // To HW
@@ -25,7 +27,6 @@ module rv_plic_reg_top (
 
   import rv_plic_reg_pkg::* ;
 
-  localparam int AW = 9;
   localparam int DW = 32;
   localparam int DBW = DW/8;                    // Byte Width
 
@@ -45,38 +46,11 @@ module rv_plic_reg_top (
   tlul_pkg::tl_h2d_t tl_reg_h2d;
   tlul_pkg::tl_d2h_t tl_reg_d2h;
 
-  // incoming payload check
-  logic intg_err;
-  tlul_cmd_intg_chk u_chk (
-    .tl_i,
-    .err_o(intg_err)
-  );
-
-  logic intg_err_q;
-  always_ff @(posedge clk_i or negedge rst_ni) begin
-    if (!rst_ni) begin
-      intg_err_q <= '0;
-    end else if (intg_err) begin
-      intg_err_q <= 1'b1;
-    end
-  end
-
-  // integrity error output is permanent and should be used for alert generation
-  // register errors are transactional
-  assign intg_err_o = intg_err_q | intg_err;
-
-  // outgoing integrity generation
-  tlul_pkg::tl_d2h_t tl_o_pre;
-  tlul_rsp_intg_gen #(
-    .EnableRspIntgGen(1),
-    .EnableDataIntgGen(1)
-  ) u_rsp_intg_gen (
-    .tl_i(tl_o_pre),
-    .tl_o
-  );
+  assign intg_err_o = '0;
 
   assign tl_reg_h2d = tl_i;
-  assign tl_o_pre   = tl_reg_d2h;
+  assign tl_o = tl_reg_d2h;
+
 
   tlul_adapter_reg #(
     .RegAw(AW),
@@ -99,7 +73,8 @@ module rv_plic_reg_top (
   );
 
   assign reg_rdata = reg_rdata_next ;
-  assign reg_error = (devmode_i & addrmiss) | wr_err | intg_err;
+  assign reg_error = (devmode_i & addrmiss) | wr_err;
+
 
   // Define SW related signals
   // Format: <reg>_<field>_{wd|we|qs}
@@ -4507,10 +4482,9 @@ module rv_plic_reg_top (
 
   `ASSERT(reAfterRv, $rose(reg_re || reg_we) |=> tl_o.d_valid)
 
-  `ASSERT(en2addrHit, (reg_we || reg_re) |-> $onehot0(addr_hit))
-
   // this is formulated as an assumption such that the FPV testbenches do disprove this
   // property by mistake
   //`ASSUME(reqParity, tl_reg_h2d.a_valid |-> tl_reg_h2d.a_user.chk_en == tlul_pkg::CheckDis)
+  `ASSERT(en2addrHit, (reg_we || reg_re) |-> $onehot0(addr_hit))
 
 endmodule
