// File auto-generated by Padrick 0.3.1.post0.dev2+ge09286c
module padframe_xheep_muxer
  import pkg_internal_padframe_xheep::*;
  import pkg_padframe::*;
  import padframe_xheep_config_reg_pkg::*;
#(
    parameter type req_t  = logic,  // reg_interface request type
    parameter type resp_t = logic   // reg_interface response type
) (
    input logic clk_i,
    input logic rst_ni,
    input pad_domain_xheep_ports_soc2pad_t port_signals_soc2pad_i,
    output pad_domain_xheep_ports_pad2soc_t port_signals_pad2soc_o,
    output mux_to_pads_t mux_to_pads_o,
    input pads_to_mux_t pads_to_mux_i,
    // Configuration interface using register_interface protocol
    input req_t config_req_i,
    output resp_t config_rsp_o
);
  // Connections between register file and pads
  padframe_xheep_config_reg2hw_t s_reg2hw;

  // Register File Instantiation
  padframe_xheep_config_reg_top #(
      .reg_req_t(req_t),
      .reg_rsp_t(resp_t)
  ) i_regfile (
      .clk_i,
      .rst_ni,
      .reg2hw(s_reg2hw),
      .reg_req_i(config_req_i),
      .reg_rsp_o(config_rsp_o),
      .devmode_i(1'b1)
  );


  // SoC -> Pad Multiplex Logic
  // Pad pad_io_30
  always_comb begin
    unique case (s_reg2hw.pad_io_30_mux_sel.q)
      PAD_MUX_GROUP_PAD30_SEL_DEFAULT: begin
        mux_to_pads_o.pad_io_30.chip2pad  = s_reg2hw.pad_io_30_cfg.chip2pad.q;
        mux_to_pads_o.pad_io_30.output_en = s_reg2hw.pad_io_30_cfg.output_en.q;
      end
      PAD_MUX_GROUP_PAD30_SEL_I2C_I2C_SDA: begin
        mux_to_pads_o.pad_io_30.chip2pad  = port_signals_soc2pad_i.i2c.i2c_sda_i;
        mux_to_pads_o.pad_io_30.output_en = port_signals_soc2pad_i.i2c.i2c_sda_oe_i;
      end
      PAD_MUX_GROUP_PAD30_SEL_GPIO_GPIO_30: begin
        mux_to_pads_o.pad_io_30.chip2pad  = port_signals_soc2pad_i.gpio.gpio_30_i;
        mux_to_pads_o.pad_io_30.output_en = port_signals_soc2pad_i.gpio.gpio_30_oe_i;
      end
      default: begin
        mux_to_pads_o.pad_io_30.chip2pad  = s_reg2hw.pad_io_30_cfg.chip2pad.q;
        mux_to_pads_o.pad_io_30.output_en = s_reg2hw.pad_io_30_cfg.output_en.q;
      end
    endcase
  end  // always_comb

  // Pad pad_io_31
  always_comb begin
    unique case (s_reg2hw.pad_io_31_mux_sel.q)
      PAD_MUX_GROUP_PAD31_SEL_DEFAULT: begin
        mux_to_pads_o.pad_io_31.chip2pad  = s_reg2hw.pad_io_31_cfg.chip2pad.q;
        mux_to_pads_o.pad_io_31.output_en = s_reg2hw.pad_io_31_cfg.output_en.q;
      end
      PAD_MUX_GROUP_PAD31_SEL_I2C_I2C_SCL: begin
        mux_to_pads_o.pad_io_31.chip2pad  = port_signals_soc2pad_i.i2c.i2c_scl_i;
        mux_to_pads_o.pad_io_31.output_en = port_signals_soc2pad_i.i2c.i2c_scl_oe_i;
      end
      PAD_MUX_GROUP_PAD31_SEL_GPIO_GPIO_31: begin
        mux_to_pads_o.pad_io_31.chip2pad  = port_signals_soc2pad_i.gpio.gpio_31_i;
        mux_to_pads_o.pad_io_31.output_en = port_signals_soc2pad_i.gpio.gpio_31_oe_i;
      end
      default: begin
        mux_to_pads_o.pad_io_31.chip2pad  = s_reg2hw.pad_io_31_cfg.chip2pad.q;
        mux_to_pads_o.pad_io_31.output_en = s_reg2hw.pad_io_31_cfg.output_en.q;
      end
    endcase
  end  // always_comb


  // Pad -> SoC Multiplex Logic
  // Port Group i2c

  // Port Signal i2c_scl_o
  logic [0:0] port_mux_sel_i2c_i2c_scl_o_req;
  logic [PORT_MUX_GROUP_PAD31_SEL_WIDTH-1:0] port_mux_sel_i2c_i2c_scl_o_arbitrated;
  logic port_mux_sel_i2c_i2c_scl_o_no_connection;

  assign port_mux_sel_i2c_i2c_scl_o_req[PORT_MUX_GROUP_PAD31_SEL_PAD_IO_31] = s_reg2hw.pad_io_31_mux_sel.q == PAD_MUX_GROUP_PAD31_SEL_I2C_I2C_SCL ? 1'b1 : 1'b0;

  lzc #(
      .WIDTH(1),
      .MODE (1'b0)
  ) i_port_muxsel_i2c_i2c_scl_o_arbiter (
      .in_i(port_mux_sel_i2c_i2c_scl_o_req),
      .cnt_o(port_mux_sel_i2c_i2c_scl_o_arbitrated),
      .empty_o(port_mux_sel_i2c_i2c_scl_o_no_connection)
  );

  always_comb begin
    if (port_mux_sel_i2c_i2c_scl_o_no_connection) begin
      port_signals_pad2soc_o.i2c.i2c_scl_o = 1'b0;
    end else begin
      unique case (port_mux_sel_i2c_i2c_scl_o_arbitrated)
        PORT_MUX_GROUP_PAD31_SEL_PAD_IO_31: begin
          port_signals_pad2soc_o.i2c.i2c_scl_o = pads_to_mux_i.pad_io_31.pad2chip;
        end
        default: begin
          port_signals_pad2soc_o.i2c.i2c_scl_o = 1'b0;
        end
      endcase
    end
  end


  // Port Signal i2c_sda_o
  logic [0:0] port_mux_sel_i2c_i2c_sda_o_req;
  logic [PORT_MUX_GROUP_PAD30_SEL_WIDTH-1:0] port_mux_sel_i2c_i2c_sda_o_arbitrated;
  logic port_mux_sel_i2c_i2c_sda_o_no_connection;

  assign port_mux_sel_i2c_i2c_sda_o_req[PORT_MUX_GROUP_PAD30_SEL_PAD_IO_30] = s_reg2hw.pad_io_30_mux_sel.q == PAD_MUX_GROUP_PAD30_SEL_I2C_I2C_SDA ? 1'b1 : 1'b0;

  lzc #(
      .WIDTH(1),
      .MODE (1'b0)
  ) i_port_muxsel_i2c_i2c_sda_o_arbiter (
      .in_i(port_mux_sel_i2c_i2c_sda_o_req),
      .cnt_o(port_mux_sel_i2c_i2c_sda_o_arbitrated),
      .empty_o(port_mux_sel_i2c_i2c_sda_o_no_connection)
  );

  always_comb begin
    if (port_mux_sel_i2c_i2c_sda_o_no_connection) begin
      port_signals_pad2soc_o.i2c.i2c_sda_o = 1'b0;
    end else begin
      unique case (port_mux_sel_i2c_i2c_sda_o_arbitrated)
        PORT_MUX_GROUP_PAD30_SEL_PAD_IO_30: begin
          port_signals_pad2soc_o.i2c.i2c_sda_o = pads_to_mux_i.pad_io_30.pad2chip;
        end
        default: begin
          port_signals_pad2soc_o.i2c.i2c_sda_o = 1'b0;
        end
      endcase
    end
  end

  // Port Group gpio

  // Port Signal gpio_30_o
  logic [0:0] port_mux_sel_gpio_gpio_30_o_req;
  logic [PORT_MUX_GROUP_PAD30_SEL_WIDTH-1:0] port_mux_sel_gpio_gpio_30_o_arbitrated;
  logic port_mux_sel_gpio_gpio_30_o_no_connection;

  assign port_mux_sel_gpio_gpio_30_o_req[PORT_MUX_GROUP_PAD30_SEL_PAD_IO_30] = s_reg2hw.pad_io_30_mux_sel.q == PAD_MUX_GROUP_PAD30_SEL_GPIO_GPIO_30 ? 1'b1 : 1'b0;

  lzc #(
      .WIDTH(1),
      .MODE (1'b0)
  ) i_port_muxsel_gpio_gpio_30_o_arbiter (
      .in_i(port_mux_sel_gpio_gpio_30_o_req),
      .cnt_o(port_mux_sel_gpio_gpio_30_o_arbitrated),
      .empty_o(port_mux_sel_gpio_gpio_30_o_no_connection)
  );

  always_comb begin
    if (port_mux_sel_gpio_gpio_30_o_no_connection) begin
      port_signals_pad2soc_o.gpio.gpio_30_o = 1'b0;
    end else begin
      unique case (port_mux_sel_gpio_gpio_30_o_arbitrated)
        PORT_MUX_GROUP_PAD30_SEL_PAD_IO_30: begin
          port_signals_pad2soc_o.gpio.gpio_30_o = pads_to_mux_i.pad_io_30.pad2chip;
        end
        default: begin
          port_signals_pad2soc_o.gpio.gpio_30_o = 1'b0;
        end
      endcase
    end
  end


  // Port Signal gpio_31_o
  logic [0:0] port_mux_sel_gpio_gpio_31_o_req;
  logic [PORT_MUX_GROUP_PAD31_SEL_WIDTH-1:0] port_mux_sel_gpio_gpio_31_o_arbitrated;
  logic port_mux_sel_gpio_gpio_31_o_no_connection;

  assign port_mux_sel_gpio_gpio_31_o_req[PORT_MUX_GROUP_PAD31_SEL_PAD_IO_31] = s_reg2hw.pad_io_31_mux_sel.q == PAD_MUX_GROUP_PAD31_SEL_GPIO_GPIO_31 ? 1'b1 : 1'b0;

  lzc #(
      .WIDTH(1),
      .MODE (1'b0)
  ) i_port_muxsel_gpio_gpio_31_o_arbiter (
      .in_i(port_mux_sel_gpio_gpio_31_o_req),
      .cnt_o(port_mux_sel_gpio_gpio_31_o_arbitrated),
      .empty_o(port_mux_sel_gpio_gpio_31_o_no_connection)
  );

  always_comb begin
    if (port_mux_sel_gpio_gpio_31_o_no_connection) begin
      port_signals_pad2soc_o.gpio.gpio_31_o = 1'b0;
    end else begin
      unique case (port_mux_sel_gpio_gpio_31_o_arbitrated)
        PORT_MUX_GROUP_PAD31_SEL_PAD_IO_31: begin
          port_signals_pad2soc_o.gpio.gpio_31_o = pads_to_mux_i.pad_io_31.pad2chip;
        end
        default: begin
          port_signals_pad2soc_o.gpio.gpio_31_o = 1'b0;
        end
      endcase
    end
  end

endmodule : padframe_xheep_muxer
